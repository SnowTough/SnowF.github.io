<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Java后端面试题收集"><meta name="keywords" content=""><meta name="author" content="SnowF"><meta name="copyright" content="SnowF"><title>Java后端面试题收集 | SnowF's Blog</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.9.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.9.1"><meta name="format-detection" content="telephone=no"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  hexoVersion: '6.3.0'
} </script><meta name="generator" content="Hexo 6.3.0"></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar" data-display="true"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">SnowF</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">20</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">12</span></a><a class="author-info-articles__categories article-meta" href="/categories"><span class="pull-left">分类</span><span class="pull-right">7</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://w.wallhaven.cc/full/9d/wallhaven-9dmeyw.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">SnowF's Blog</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus">   <a class="site-page" href="/">主页</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">目录</a></span><span class="pull-right"></span></div><div id="post-info"><div id="post-title">Java后端面试题收集</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2023-02-17</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><ol>
<li>Java 面向对象的三个特征</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">封装：对象只需要选择性地对外公开一些属性和行为，只对外暴露相应接口</span><br><span class="line">继承：子对象可以继承父对象的属性和行为，并且可以在其之上进行修改以适合更特殊的场景需求</span><br><span class="line">多态：允许不同类的对象对同一消息做出响应</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>Java 中基本的数据类型有哪些，占用多少字节</li>
</ol>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>占用字节</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>1</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
</tr>
<tr>
<td>boolean</td>
<td>4</td>
</tr>
</tbody></table>
<ol start="3">
<li>int和Integer的区别</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int 是 Java 中的原始类型，Integer 是 Java 为 int 提供的封装类，他们有不同的特征和用法，包括 大小、速度、默认值</span><br></pre></td></tr></table></figure>




<ol start="4">
<li>String、StringBuilder、StringBuffer 的区别及使用场景</li>
</ol>
<table>
<thead>
<tr>
<th>项</th>
<th>String</th>
<th>StringBuffer</th>
<th>StringBuilder</th>
</tr>
</thead>
<tbody><tr>
<td>可变性</td>
<td>不可变<br />原因：value 数组是 final 类型。<br />因为不可变，所以每次操作生成新对象</td>
<td>可变<br />原因：其父类（AbstractStringBuilder）的 value 数组不是 final 类型</td>
<td>可变<br />原因：其父类（AbstractStringBuiilder）的 value 数组不是 final 类型</td>
</tr>
<tr>
<td>线程安全性</td>
<td>线程安全<br />原因：value 数组是 final 类型</td>
<td>线程安全<br />原因：方法使用了 synchronized</td>
<td>线程不安全</td>
</tr>
</tbody></table>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String 一旦定义就不可改变，可空赋值。操作少量数据时使用</span><br><span class="line">StringBuilder 可改变，线程不安全。操作单线程大量数据时使用</span><br><span class="line">StringBuffer 可改变，线程安全。操作多线程大量数据时使用</span><br></pre></td></tr></table></figure>



<ol start="5">
<li>String不可变的含义、原因、好处</li>
</ol>
<p>​	含义：将一个已有的字符串“123”重新赋值成“456”，不是在原内存地址上修改数据，而是重新指向一个新对象，新地址；也就是说：不可变的含义是内部数据不可变，而不是说引用不可变</p>
<p>​	原因：String 内部数据是一个 char 数组，是对字符串数组的封装，并且是被 final 修饰的，创建后不可改变</p>
<p>​	好处：</p>
<p>​	1、便于实现字符串池（String pool）</p>
<p>​		在 Java 中，由于会大量使用 String 常量，如果每一次声明一个 String 都创建一个 String 对象，将会造成极大的空间资源浪费。Java 提出了 String pool 的概念，在堆中开辟一块存储空间 String pool，当初始化一个 String 变量时，如果该字符串已经存在了，就不会去创建一个新的字符串变量，而是会返回已经存在了的字符串的引用。</p>
<p>​		如果字符串是可变的，某一个字符串变量改变了其值，那么其指向的变量的值也会改变，String pool 将不能实现。</p>
<p>​		例如：以下代码中，就只会在字符串池中创建一个字符串“Hello World”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>​	2、使多线程安全</p>
<p>​		在如下场景中，一个函数 appendStr() 在不可变的 String 参数后面加上一段 “bbb” 后返回，appendSb() 负责在可变的 StringBuilder 后面加上 “bbb”</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">  <span class="comment">// 不可变的 String </span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">appendStr</span> <span class="params">(String s)</span> &#123;</span><br><span class="line">    s += <span class="string">&quot;bbb&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 可变的 StringBuilder</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> StringBuilder <span class="title function_">appendSb</span> <span class="params">(StringBuilder sb)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sb.append(<span class="string">&quot;bbb&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">ns</span> <span class="operator">=</span> test.appendStr(s);</span><br><span class="line">    System.out.println(<span class="string">&quot;String aaa&gt;&gt;&gt;&quot;</span> + s.toString());</span><br><span class="line">    <span class="comment">// StringBuilder 作为参数</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">nsb</span> <span class="operator">=</span> test.appendSb(sb);</span><br><span class="line">    System.out.println(<span class="string">&quot;StringBuilder aaa&gt;&gt;&gt;&quot;</span> + sb.toString());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line">String aaa&gt;&gt;&gt;aaa</span><br><span class="line">StringBuilder aaa&gt;&gt;&gt;aaabbb</span><br></pre></td></tr></table></figure>

<p>​		在并发场景下，多个线程同时读一个资源，是安全的，不会引发竞争，但对资源进行写操作时是不安全的，不可变对象不能被写，所以保证了多线程的安全</p>
<p>​	3、避免安全问题</p>
<p>​		在网络连接和数据库连接中字符串常常作为参数，例如：网络连接地址 URL，文件路径 path，反射机制所需要的 String 参数。其不可变性可以保证连接的安全性。如果字符串是可变的，黑客就有可能改变字符串指向的对象的值，会引发严重安全问题。</p>
<p>​		因为 String 是不可变的，所以它的值是不可改变的。但由于 String 不可变，也就没有任何方式能修改字符串的值，每一次修改都将产生新的字符串，如果使用 char[] 来保存密码，仍然能够将其中所有的元素设置为空和清零，也不会被放入字符串缓存池中，用字符串数组来保存密码会更好。</p>
<p>​	4、 加快字符串处理速度</p>
<p>​		由于 String 是不可变的，保证了 hashCode 的唯一性，于是在创建对象时其 hashCode 就可以放心进行缓存了，不需要重新计算。这也就是一般将 String 作为 Map 的 key 的原因，处理速度要快过其他的键对象。所以 HashMap 中的键往往都使用 String</p>
<p>​		在 String 类的定义中有如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">int</span> hash; <span class="comment">// 用来缓存 HashCode</span></span><br></pre></td></tr></table></figure>

<p>​	补充：String 的字符数据依旧可变，如何改变？</p>
<p>​		String 类使用 char value[] 来存储字符数据，它的类型为：private final char value[];</p>
<p>​		虽然看上去是 final 类型，无法改变。但是：<strong>final 只是表示不能指向其他地址，它里面的内容依旧是可以改变的！</strong></p>
<p>​		所以，String 依旧可以更改，使用反射机制，value.setAccessible(true)，然后修改它即可，例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;改变前：&quot;</span> + s);</span><br><span class="line"></span><br><span class="line"><span class="type">Field</span> <span class="variable">f</span> <span class="operator">=</span> s.getClass().getDeclaredField(<span class="string">&quot;value&quot;</span>);</span><br><span class="line">f.setAccessible(<span class="literal">true</span>);</span><br><span class="line">f.set(s, <span class="keyword">new</span> <span class="title class_">char</span>[]&#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;);</span><br><span class="line">System.out.println(<span class="string">&quot;改变后：&quot;</span> + s);</span><br></pre></td></tr></table></figure>





<ol start="6">
<li>ArrayList、Vector 和 LinkedList 的区别及使用场景</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList 和 Vector 都是使用数组方式存储数据，允许按索引号索引元素，但是插入数据会涉及到元素移动等内存操作，所以索引快插入慢</span><br><span class="line">ArrayList 懒加载（按需加载），默认大小 10，每次扩容 1.5 倍，线程不安全，性能较高</span><br><span class="line">Vector 实例化时初始化，默认大小 10，每次扩容 2 倍，线程安全，性能较低，已弃用</span><br><span class="line">LinkedList 使用双向链表方式存储数据，插入只需要记录本项的前后项，索引需要向前或向后进行遍历，所以插入速度较快，线程不安全，频繁在任意位置插入和删除的情况可以使用，如果需要多线程访问，可以使用 Connections.synchronizedList() 或 ConcurrentLinkedQueue()</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>加分项：</strong></p>
<p>多读少写建议使用 CopyOnWriteArrayList</p>
<p>CopyOnWriteArrayList 原理是发生修改的时候复制一份</p>
<p>多写少读或读写比较均匀建议使用 Connections.synchronizedList</p>
</blockquote>
<ol start="7">
<li>为什么静态方法不能调用非静态方法和变量（涉及到 JVM）</li>
</ol>
<p>​	举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">  <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;静态变量&quot;</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(a);</span><br><span class="line">    System.out.println(b);</span><br><span class="line">    test();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result：</span></span><br><span class="line">java: 无法从静态上下文中引用非静态变量</span><br></pre></td></tr></table></figure>

<p>​	原因：</p>
<p>​		jvm 中类加载的生命周期图：</p>
<img src="https://p.ipic.vip/7bdzig.png" alt="截屏2023-02-18 14.44.52" style="zoom: 50%;" />

<p>​	1、加载</p>
<p>​		“加载”是“类加载机制的第一个过程，在加载阶段，虚拟机主要完成三件事：</p>
<p>​		（1）通过一个类的全限定名来获取其定义的二进制字节流</p>
<p>​		（2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构</p>
<p>​		（3）在堆中生成一个代表这个类的 Class 对象，作为方法区中这些数据的访问入口</p>
<p>​		<strong>注意此时会扫描我们代码中是否有静态变量或是静态方法等。这些静态数据结构还未分配内存</strong></p>
<p>​	2、验证</p>
<p>​		验证的主要作用就是确保被加载的类的正确性</p>
<p>​	3、准备</p>
<p>​		<strong>准备阶段主要为类变量分配内存并设置初始值。</strong>这些内存都在方法区分配。<strong>注意此时就会为我们的类变量也就是静态变量分配内存，但是普通成员变量还未分配</strong></p>
<p>​	4、解析</p>
<p>​		解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程</p>
<p>​	5、初始化</p>
<p>​		这是类加载机制的最后一步，在这个阶段，java 程序代码才开始真正执行。在准备阶段已经为类变量赋过一次值。在初始化阶段，程序员可以根据自己的需求来赋值了，<strong>初始化的时候才会为我们的普通成员变量赋值</strong></p>
<p>​	总结：</p>
<p>​		静态方法和静态变量是属于某一个类，而不属于类的对象。而动态方法属于实例对象，在类加的时候就会分配内存，可以通过类名直接访问，非静态成员（变量和方法）属于类的对象，所以只有该对象初始化之后才存在，然后通过类的对象去访问。</p>
<p>​		也就是说如果我们在静态方法中调用非静态成员变量会超前，可能会调用到还未初始化的变量，因此编译器会报错。</p>
<ol start="8">
<li>字节流和字符流的区别</li>
</ol>
<table>
<thead>
<tr>
<th>项</th>
<th>字节流</th>
<th>字符流</th>
</tr>
</thead>
<tbody><tr>
<td>操作基本单元</td>
<td>字节</td>
<td>字符（Unicode 码元）</td>
</tr>
<tr>
<td>是否使用缓冲</td>
<td>否</td>
<td>是<br />若频繁对一个资源进行 IO 操作，会先把需要操作的数据暂时放入内存中，以后直接从内存中读取数据。<br />这样可以避免多次 IO 操作，提高效率</td>
</tr>
<tr>
<td>存在位置</td>
<td>可存在于文件、内存中。<br />硬盘上的所有文件都是以字节形式存在的</td>
<td>只存在于内存中</td>
</tr>
<tr>
<td>使用场景</td>
<td>适合操作文本文件之外的文件。<br />例：图片、音频、视频</td>
<td>适合操作文本文件时使用<br />（效率高，因为有缓存）</td>
</tr>
<tr>
<td>Java 相关类</td>
<td>InputStream、OutputStream</td>
<td>Reader、Writer</td>
</tr>
</tbody></table>
<ol start="8">
<li>JDK8 新特性</li>
</ol>
<p>​		接口允许 default 和 static；Lambda；stream；时间新 API（LocalDateTime 等）CompletableFuture；等等……</p>
<ol start="9">
<li>List 和 Set 的区别</li>
</ol>
<p>​	ArrayList 与 LinkedLIst 异同</p>
<p>​		相同点：</p>
<table>
<thead>
<tr>
<th>ArrayList 与 LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>都是线程不安全的</td>
</tr>
<tr>
<td>都按照存入的顺序取出</td>
</tr>
</tbody></table>
<p>​		不同点：</p>
<table>
<thead>
<tr>
<th>项</th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>实现方式</td>
<td>基于数组</td>
<td>基于链表</td>
</tr>
<tr>
<td>随机访问</td>
<td>支持随机访问（实现留 RandomAccess 接口）</td>
<td>不支持随机访问</td>
</tr>
<tr>
<td>时间复杂度</td>
<td>顺序表</td>
<td>链表</td>
</tr>
<tr>
<td>插入效率</td>
<td>低（需要扩容时效率会变低）</td>
<td>高</td>
</tr>
<tr>
<td>使用场景</td>
<td>随机访问的场景</td>
<td>插入很频繁的场景<br />用作：栈、队列或双向队列</td>
</tr>
</tbody></table>
<p>​	List 和 Set 区别</p>
<table>
<thead>
<tr>
<th>项</th>
<th>List</th>
<th>Set</th>
</tr>
</thead>
<tbody><tr>
<td>重复</td>
<td>允许重复的对象（多个 null 也可以）</td>
<td>不允许重复的对象（null 也只能有一个）</td>
</tr>
<tr>
<td>有序性</td>
<td>有序<br />保持每个元素的插入顺序。即输出顺序就是输入顺序</td>
<td>无序<br />无法保证每个元素的存储顺序</td>
</tr>
</tbody></table>
<p>​	ArrayList 和 Array 区别</p>
<table>
<thead>
<tr>
<th>项</th>
<th>Array</th>
<th>ArrayList</th>
</tr>
</thead>
<tbody><tr>
<td>数据类型</td>
<td>可以包含基本类型和对象类型</td>
<td>只能包含对象类型</td>
</tr>
<tr>
<td>大小</td>
<td>大小是固定的，Array 对象的初始化必须指定大小</td>
<td>大小是动态的</td>
</tr>
<tr>
<td>数据存放</td>
<td>连续存放</td>
<td>存放不一定连续</td>
</tr>
<tr>
<td>插入与删除</td>
<td>不能够添加和删除其中的项</td>
<td>可以在任意位置插入和删除项</td>
</tr>
<tr>
<td>效率</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<p>​	ArrayList 和 ArrayList 相同点</p>
<table>
<thead>
<tr>
<th>Array 和 ArrayList</th>
</tr>
</thead>
<tbody><tr>
<td>都具有索引（index），即：可以通过 index 来直接获取和修改任意项</td>
</tr>
<tr>
<td>他们所创建的对象都放在堆中</td>
</tr>
<tr>
<td>都能够对自身进行枚举（因为都实现了 Enumerable 接口）</td>
</tr>
</tbody></table>
<ol start="10">
<li>（Important）Arraylist 保证线程安全的方法</li>
</ol>
<p>​	ArrayList</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>Vector</td>
<td>List list &#x3D; new ArrayList(); <br />替换为 List arrayList &#x3D; new Vector&lt;&gt;();</td>
<td>使用了 synchronized 关键字</td>
</tr>
<tr>
<td>Collections.synchronizedList(list)</td>
<td>List<String> list &#x3D; Collections.synchronizedList(new ArrayList<String>);<br />操作外部 list，实际上修改的是原来 list 的数据</td>
<td>所有方法都加了 synchronized 修饰，加锁的对象是当前 SynchronizedCollection 实例</td>
</tr>
<tr>
<td>JUC 中的 CopyOnWriteArrayList</td>
<td>CopyOnWriteArrayList<String> list &#x3D; new CopyOnWriteArrayList<String>();<br />适用于读多写少的并发场景</td>
<td>Write 的时候总是要 Copy（将原来 array 复制到新的 array，修改后，将引用指向新数组）。任何可变的操作（add、set、remove 等）都通过 ReentrantLock 控制并发</td>
</tr>
</tbody></table>
<p>​	LinkedList</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>示例</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td>Collections.synchronizedList(list)</td>
<td>public static List linkedList &#x3D; Collections.synchronizedList(new LinkedList(new LinkedList()));</td>
<td>所有方法都加了 synchronized 修饰。加锁的对象是当前 SynchronizedCollection 实例</td>
</tr>
<tr>
<td>JUC 中的 ConcurrentLinkedQueue</td>
<td>ConcurrentLinkedQueue<String> queue &#x3D; new ConcurrentLinkedQueue();</td>
<td></td>
</tr>
</tbody></table>
<ol start="11">
<li>静态代理和动态代理的区别</li>
</ol>
<p>​		代理模式：为某个对象提供一个代理，以控制这个对象的访问。代理类和委托类<strong>有共同的父类或父接口</strong>，这样在<strong>任何使用委托类对象的地方都可以用代理对象替代。</strong>代理类负责请求的预处理、过滤、将请求分派给委托类处理、以及委托类执行完请求后的后续处理。</p>
<img src="https://p.ipic.vip/bf8f1o.png" alt="image-20230218234949405" style="zoom:50%;" />

<p>​		<strong>根据代理类的生成时间不同</strong>可以将代理分为静态代理和动态代理两种</p>
<p>​	静态代理与动态代理区别</p>
<table>
<thead>
<tr>
<th>项</th>
<th>静态代理</th>
<th>动态代理</th>
</tr>
</thead>
<tbody><tr>
<td>代理类字节码创建的时间</td>
<td><strong>程序运行前</strong>就存在代理类的字节码文件，代理类和委托类的关系在运行前就确定了。<br />  程序员创建或工具生成代理类的源码，再编译代理类。</td>
<td>不存在代理类的字节码文件。动态代理类的源码是在<strong>程序运行期间由 JVM 根据反射等机制动态地生成</strong>的，代理类和委托类的关系是在程序运行时确定。</td>
</tr>
<tr>
<td>接口有多个方法的处理</td>
<td>如果接口增加一个方法，除了所有实现类需要实现这个方法外，<strong>所有代理类也需要实现此方法。</strong></td>
<td>接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理，接口方法数量比较多的时候，<strong>不需要像静态代理那样每一个方法进行中转。</strong><br />  在本示例中无法看出，因为 invoke 方法体内嵌入了具体的外围业务（记录任务处理前后时间并计算时间差），实际中可以类似 Spring AOP 那样配置外围业务。</td>
</tr>
</tbody></table>
<p>​	静态代理示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> org.example.a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理接口</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ExecuteTime</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dealTask</span><span class="params">(String taskName)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecuteTimeImpl</span> <span class="keyword">implements</span> <span class="title class_">ExecuteTime</span> &#123;</span><br><span class="line">  <span class="comment">// 这里打印出任务名，并休眠 500ms 模拟任务执行了很长时间</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dealTask</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Task is running: &quot;</span> + taskName);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Thread.sleep(<span class="number">500</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExecuteTimeProxy</span> <span class="keyword">implements</span> <span class="title class_">ExecuteTime</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">ExecuteTime</span> <span class="variable">delegate</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ExecuteTimeProxy</span><span class="params">(ExecuteTimeImpl ExecuteTimeImpl)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.delegate = ExecuteTimeImpl;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dealTask</span><span class="params">(String taskName)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">startTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    delegate.dealTask(taskName);</span><br><span class="line">    <span class="type">long</span> <span class="variable">endTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;Elapsed time: &quot;</span> + (endTime-startTime) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工厂方法获得代理对象</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticProxyFactory</span> &#123;</span><br><span class="line">  <span class="comment">// 对客户类来说，其并不知道返回的是代理类对象还是委托类对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> ExecuteTime <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ExecuteTimeProxy</span>(<span class="keyword">new</span> <span class="title class_">ExecuteTimeImpl</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">ExecuteTime</span> <span class="variable">proxy</span> <span class="operator">=</span> StaticProxyFactory.getInstance();</span><br><span class="line">    proxy.dealTask(<span class="string">&quot;TestTask&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	动态代理示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 利用反射机制在运行时创建代理类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Object object;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ProxyHandler</span> <span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.object = object;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">invoke</span> <span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Before invoke &quot;</span> + method.getName());</span><br><span class="line">    method.invoke(object, args);</span><br><span class="line">    System.out.println(<span class="string">&quot;After invoke &quot;</span> + method.getName());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建一个 handler 类实现 InvocationHandler 接口</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> Object object;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ProxyHandler</span> <span class="params">(Object object)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.object = object;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Before invoke&quot;</span> + method.getName());</span><br><span class="line">		method.invoke(object, args);</span><br><span class="line">		System.out.println(<span class="string">&quot;After invoke &quot;</span> + method.getName());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 执行动态代理</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;				 			System.getProperties().setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);	</span><br><span class="line">	<span class="type">HelloInterface</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">	<span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyHandler</span>(hello);</span><br><span class="line">	<span class="type">HelloInterface</span> <span class="variable">proxyHello</span> <span class="operator">=</span> (HelloInterface) Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);</span><br><span class="line"></span><br><span class="line">	proxyHello.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		通过 Proxy 类的静态方法 newProxyInstance 返回一个接口的代理实例。针对不同的代理类，传入相应的代理程序控制器 InvocationHandler</p>
<p>​		如果新来一个被代理类 Bye，如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ByeInterface</span> &#123;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">sayBye</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bye</span> <span class="keyword">implements</span> <span class="title class_">ByeInterface</span> &#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayBye</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Bye SnowF&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		执行过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.getProperties().setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="type">HelloInterface</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hello</span>();</span><br><span class="line">	<span class="type">ByeInterface</span> <span class="variable">bye</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bye</span>();</span><br><span class="line"></span><br><span class="line">	<span class="type">InvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyHandler</span>(hello);</span><br><span class="line">	<span class="type">InvocationHandler</span> <span class="variable">handler1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ProxyHandler</span>(bye);</span><br><span class="line"></span><br><span class="line">	<span class="type">HelloInterface</span> <span class="variable">proxyHello</span> <span class="operator">=</span> (HelloInterface) 	Proxy.newProxyInstance(hello.getClass().getClassLoader(), hello.getClass().getInterfaces(), handler);</span><br><span class="line">	<span class="type">ByeInterface</span> <span class="variable">proxyBye</span> <span class="operator">=</span> (ByeInterface) Proxy.newProxyInstance(bye.getClass().getClassLoader(), bye.getClass().getInterfaces(), handler1);</span><br><span class="line"></span><br><span class="line">	proxyBye.sayBye();</span><br><span class="line">	proxyHello.sayHello();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>动态代理底层实现</strong></p>
<p>​		动态代理具体步骤：</p>
<p>​			1、通过实现 InvocationHandler 接口创建自己的调用处理器</p>
<p>​			2、通过为 Proxy 类指定 ClassLoader 对象和一组 interface 来创建动态代理类</p>
<p>​			3、通过反射机制获得动态代理类的构造函数，其唯一参数类型是调用处理器接口类型</p>
<p>​			4、通过构造函数创建动态代理类实例，构造时调用处理器对象作为参数被传入</p>
<ol start="12">
<li>AOP原理</li>
</ol>
<p>​	<strong>简介：</strong></p>
<p>​		AOP 即面相切面编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p>
<p>​		通俗地讲：不通过修改源代码方式，在主干功能里添加新功能。</p>
<p>​		例如：</p>
<img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5d45d797cda742f4b9ddc90b8ad617b6~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.image?" alt="AOP概念举例" style="zoom:67%;" />

<p>​		Spring AOP 的本质是用<strong>代理模式（动态代理）</strong>，基于 BeanPostProcessor 实现，从而能够与 IOC 结合起来。</p>
<p>​	<strong>引入 AOP 的方法</strong></p>
<p>​		如果引入的是 spring-top 包，则需要使用 @EnableAspectJAutoProxy 开启 AOP 功能；如果引入的是 spring-boot-starter-aop，则 AOP 就直接可以用了，无需加注解之类的开启它</p>
<ul>
<li>spring-boot-starter-aop（此包里包含 spring-top 与 aspectjweaver）<ul>
<li>spring-aop：AOP 核心功能，例如代理工厂等</li>
<li>aspectjweaver：支持切入点表达式、aop 相关注解等（本依赖包含 aspectjrt）<ul>
<li>aspectjrt：支持 aop 相关注解等</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>​	<strong>AOP 的启用</strong></p>
<p>​		导入包即可，默认开启：spring.aop.auto &#x3D; true  &#x2F;&#x2F; 等价于 @EnableAspectJAutoProxy</p>
<p>​	<strong>JDK 代理与 CGLIB 代理</strong></p>
<p>​		SpringBoot 1.5.x：默认使用 JDK 代理，即：spring.aop.proxy-target-class&#x3D;false 若设置为 true，则使用 CGLIB动态代理</p>
<p>​		SpringBoot 2.x：默认使用 CGLIB 代理，即：spring.aop.proxy-target-class&#x3D;true</p>
<p>​		对应的自动配置为：org.springframework.boot.autoconfigure.aop.AopAutoConfiguration</p>
<p>​	<strong>为什么 SpringBoot 2.x，默认使用 CGLIB 代理</strong></p>
<p>​		以下是 Spring issue 的原话：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">We should use @EnableTransactionManagement(proxyTargetClass = true) to prevent nasty proxy issues when people aren&#x27;t using interfaces</span><br><span class="line">我们应该使用 @EnableTransactionManagement(proxyTargetClass = true) 来防止人们不使用接口时出现讨厌的代理问题</span><br></pre></td></tr></table></figure>

<p>​		讨厌的代理问题如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设有一个 UserServiceImpl 和 UserService 类，此时需要在 UserController 中使用 UserService。在 Spring 中通常都习惯这样写代码：</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserService userService;</span><br></pre></td></tr></table></figure>

<p>​		在这种情况下，无论是使用 JDK 动态代理，还是 CGLIB 都不会出现问题。但是，如果代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">UserServiceImpl userService;</span><br></pre></td></tr></table></figure>

<p>​		此时如果使用 JDK 动态代理，那在启动时就会报错：</p>
<img src="https://img-blog.csdnimg.cn/e4ddbe2efb234ff5a00f5afee5bfbe3e.png" alt="JDK动态代理报错" style="zoom:67%;" />

<p>​	<strong>AOP 相关术语</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1）连接点：类里面哪些方法可以被增强，这些方法称为连接点</span><br><span class="line">2）切入点：实际真正增强的方法称为切入点</span><br><span class="line">3）通知（增强）：实际增强的逻辑部分称为通知，且分为以下五种类型：</span><br><span class="line">	1、前置通知：before</span><br><span class="line">	2、后置通知：afterturning（返回通知）</span><br><span class="line">	3、环绕通知：around</span><br><span class="line">	4、异常通知：只有发生异常才会通知</span><br><span class="line">	5、最终通知：after 无论是否发生异常都会通知</span><br><span class="line">4）切面：把通知应用到切入点的过程，是一个动作</span><br></pre></td></tr></table></figure>

<p>​	<strong>AspectJ 简介</strong></p>
<p>​		spring 框架一般都是基于 AspectJ 实现 AOP 操作，AspectJ 不是 Spring 组成部分，是一个独立的 AOP 框架，一般把 AspectJ 和 Spring 框架一起使用，进行 AOP 操作</p>
<p>​	<strong>基于 AspectJ 实现 AOP 操作</strong></p>
<p>​		引入相关 jar 包</p>
<p>​	切入点表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）切入点表达式作用：知道对哪个类里的哪个方法进行增强</span><br><span class="line">（<span class="number">2</span>）语法结构：execution([权限修饰符] [返回类型（可省略）] [类全路径] [方法名称] ([参数列表]))</span><br><span class="line">（<span class="number">3</span>）例子如下：</span><br><span class="line">		例<span class="number">1</span>：对 com.atguigu.dao.BookDao 类中的 add 方法进行增强</span><br><span class="line">				execution(* com.atguigu.dao.BookDao.add(..))</span><br><span class="line">  	例<span class="number">2</span>：对 com.atguigu.dao.BookDao 类中的 所有 方法进行增强</span><br><span class="line">  			execution(* com.atguigu.dao.BookDao.*(..))</span><br><span class="line">  	例<span class="number">3</span>：对 com.atguigu.dao 包里面的所有方法进行增强</span><br><span class="line">  			execution(* com.atguigu.dao.*.*(..))</span><br></pre></td></tr></table></figure>

<p>​	<strong>注解方式</strong></p>
<p>​		1、创建被增强类，在类中定义方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;add……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		2、创建增强类（编写增强逻辑）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 配置不同类型的通知</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">  <span class="comment">// 相同切入点抽取</span></span><br><span class="line">  <span class="meta">@Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 前置通知</span></span><br><span class="line">  <span class="comment">// @Before 注解表示作为前置通知 </span></span><br><span class="line">  <span class="meta">@Before(value = &quot;pointdemo()&quot;)</span> <span class="comment">// 相同切入点抽取使用</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 后置通知（返回通知）</span></span><br><span class="line">  <span class="meta">@AfterReturning(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterReturning……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 最终通知</span></span><br><span class="line">  <span class="meta">@After(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;after……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 异常通知</span></span><br><span class="line">  <span class="meta">@AfterThrowing(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;afterThrowing……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 环绕通知</span></span><br><span class="line">  <span class="meta">@Around(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;环绕之前……&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 被增强的方法执行</span></span><br><span class="line">    proceedingJoinPoint.proceed();</span><br><span class="line">    </span><br><span class="line">    System.out.println(<span class="string">&quot;环绕之后……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​		配置通知和注解扫描，也可以使用完全注解开发配置一个 configuration 类</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置 xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                        http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- 开启注解扫描 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.atguigu.spring5.aopanno&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 开启 Aspect 生成代理对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 完全注解开发</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages=&#123;&quot;com.atguigu&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(ProxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConfigAop</span> &#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>公共切入点抽取</strong></p>
<p>​		在增强类中随便定义一个公共切入点方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line">  <span class="comment">// 相同切入点抽取 @Pointcut(value = &quot;execution(* com.atguigu.spring5.aopanno.User.add(..))&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointdemo</span><span class="params">()</span> &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 前置通知</span></span><br><span class="line">  <span class="comment">// @Before 注解表示作为前置通知 @Before(value = &quot;pointdemo()&quot;)</span></span><br><span class="line">  <span class="comment">// 相同切入点抽取使用：</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;before……&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​	<strong>基于 xml 的 AspectJ 文件方式</strong></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1. 创建两个类，增强类和被增强类，创建方法（同上一样） --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 在 spring 配置文件中创建两个类对象 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.aopxml.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.atguigu.spring5.aopxml.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3. 在 spring 配置文件中配置切入点 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置 aop 增强 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 切入点 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.atguigu.spring5.aopxml.Book.buy(..))&quot;</span> /&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 配置切面 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line">  	<span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>



<ol start="13">
<li>异常&#x2F;Exception 类型与原理</li>
</ol>
<img src="https://img-blog.csdnimg.cn/8179036a4852478dafa82ea39a1485a7.png" alt="Java异常层次结构" style="zoom: 67%;" />

<p>​		Throwable 有两个直接的子类：Error、Exception</p>
<p>​		· Error</p>
<p>​			· JVM 内部的严重问题，比如：资源不足等，无法恢复</p>
<p>​			· 处理方式：程序员不用处理</p>
<p>​		· Exception</p>
<p>​			· JVM 通过处理还可回到正常执行流程，即：可恢复</p>
<p>​			· 分 RuntimeException 和其他 Exception，或者说分为非受检异常（unchecked exception）和受检异常（checked exception）</p>
<p>​				· 使用建议：将 checked exceptions 用于可恢复的情况，将 unchecked exception 用于编程的错误</p>
<p>​			· RuntimeException（unchecked exception）</p>
<p>​				· 处理或者不处理都可以（不需要 try…catch… 或在方法声明时 throws）</p>
<p>​			· 其他 Exception（checked exception）</p>
<p>​				· Java 编译器要求程序必须捕获（try…catch）或声明抛出（方法声明时 throws）这种异常</p>
<p>​	<strong>为什么要对 unchecked 异常和 checked 异常进行区分</strong></p>
<p>​		编译器将检查你是否为所有的 checked 异常提供了异常处理机制，比如说我们使用 Class.forName() 来检查给定的字符串的 class 对象的时候，如果没有为这个方法提供异常处理，编译是无法通过的。</p>
<img src="https://img-blog.csdnimg.cn/20201009182931702.png" alt="img" style="zoom:67%;" />

<table>
<thead>
<tr>
<th></th>
<th>继承</th>
<th>处理</th>
<th>区别</th>
<th>建议</th>
</tr>
</thead>
<tbody><tr>
<td>checked异常</td>
<td>java.lang.Exception</td>
<td>必须显式地捕获或者传递，不处理编译不能通过</td>
<td>Check 异常的抛出作为方法接口的一部分，使得添加或移除早期版本中方法的异常难以实现。<br />沿调用栈向上传播的 Checked 异常破坏了顶层的方法，因为这些方法必须声明抛出所有它们调用的方法抛出的异常。</td>
<td>遇到可恢复的错误时采用</td>
</tr>
<tr>
<td>unchecked 异常</td>
<td>java.lang.RuntimeException</td>
<td>不必捕获或抛出异常，编译可以通过</td>
<td>Unchecked 异常不会使代码显得杂乱，因为其避免了不必要的 try-catch 块<br />Unchecked 异常不会因为异常声明聚集使方法声明显得杂乱<br />避免了版本问题<br />在多数情况下，处理异常的措施仅仅是向用户弹出一个错误提示消息，将错误消息写入日志，回滚事务等。无论发生何种异常，你可能会采用相同的处理措施。因此，应用程序通常包含一些集中的通用错误处理代码。如此一来，确切知道抛出了哪一种异常就不那么重要了</td>
<td>遇到不可恢复的异常</td>
</tr>
</tbody></table>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">SnowF</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/02/17/Java后端面试题收集/">http://example.com/2023/02/17/Java后端面试题收集/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com">SnowF's Blog</a>！</span></div></div><div class="post-meta__tag-list"></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2023/02/20/localStorage/"><i class="fa fa-chevron-left">  </i><span>localStorage / sessionStorage</span></a></div><div class="next-post pull-right"><a href="/2023/02/17/ServletContext/"><span>ServletContext</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(https://w.wallhaven.cc/full/9d/wallhaven-9dmeyw.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2013 - 2023 By SnowF</div><div class="framework-info"><span>驱动 - </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a target="_blank" rel="noopener" href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/lib/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.9.1"></script><script src="/js/fancybox.js?version=1.9.1"></script><script src="/js/sidebar.js?version=1.9.1"></script><script src="/js/copy.js?version=1.9.1"></script><script src="/js/fireworks.js?version=1.9.1"></script><script src="/js/transition.js?version=1.9.1"></script><script src="/js/scroll.js?version=1.9.1"></script><script src="/js/head.js?version=1.9.1"></script><script>if(/Android|webOS|iPhone|iPod|iPad|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
  $('#top-container').addClass('is-mobile')
}</script></body></html>